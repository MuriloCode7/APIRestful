-> Um ORM √© uma ferramenta usada para gerenciamento de banco de dados que interpreta os atributos de um objeto
como colunas de uma tabela no bd.

-> Para seguir os principios do SOLID, desacoplamos o typeORM do projeto passando-o como atributo
  da classe de cada repositorio. Dessa forma, √© possivel trabalhar com qualquer orm que venha a ser
  usado pela aplicacao
_______________________________________________________________________________________________________________

-> O m√©todo compare() do bcripts compara uma senha digitada em string com uma senha j√°
criptografada, e retorna true se forem iguais
_______________________________________________________________________________________________________________

-> Manipula√ß√£o de obrigatoriedade de dados com Joi e Celebrate:
ex:
password: Joi.string().optional(),
      password_confirmation: Joi.string()
      // valida se a nova senha e a confirmacao sao iguais
        .valid(Joi.ref('password'))
        // Se a nova senha tiver sido informada, a confirmacao sera exigida
        .when('password', {
          is: Joi.exist(),
          then: Joi.required(),
        }),
_______________________________________________________________________________________________________________

-> As defini√ß√µes de atributos que come√ßam com @ nas entidades
s√£o chamadas de Decorators
_______________________________________________________________________________________________________________

-> Vari√°veis de ambientes s√£o informa√ß√µes que configuramos em nossa aplica√ß√£o para que
tenham valores diferentes dependendo do ambiente em que a aplica√ß√£o est√° sendo executa√ß√£o
As valores das vari√°veis de ambiente n√£o v√£o para o Git, apenas os nomes delas
_______________________________________________________________________________________________________________

-> A biblioteca Class Transformer permite al√©m de outras coisas alterar a forma
como as informa√ß√µes das entidades ser√£o exibidas para os usuarios, permitindo at√© inibir atributos
_______________________________________________________________________________________________________________

-> Implementa√ß√£o do Redis para controle do cache. O cache guarda as requisi√ß√µes mais custosas
e as requisic√µes mais usadas
_______________________________________________________________________________________________________________

üìå Trabalhando com Redis no terminal:
- docker start redis -> Executa apenas o container do Redis
- docker exec -it redis sh -> Executa o redis cliente
- data # redis-cli
- set chave valor -> define um novo conjunto de chave e valor
- get chave -> traz o valor de uma chave
- del chave1 chave2 ... -> Deleta todas as chaves separadas¬†por¬†espa√ßo
_______________________________________________________________________________________________________________

-> A biblioteca rate-limiter controla a quantidade de requisicoes que a aplicacao
pode ter por minuto, dessa forma √© possivel proteger a aplicacao contra ataques como
brute force.
_______________________________________________________________________________________________________________

-> Usamos o Amazon S3 com os buckets para poder hospedar as imagens de avatar dos
usu√°rios
_______________________________________________________________________________________________________________

BABEL: O babel √© usado pra converter/transpilar c√≥digo tsc para js mais atualizado de forma que o node interprete
- Uma vantagem de trabalhar com o Babel no lugar do tsc √© o gerenciamento dos paths, que s√£o os caminhos definidos
com '@'.
- Instala√ß√£o:
yarn add -D @babel/cli @babel/core @babel/node @babel/preset-env @babel/preset-typescript
@babel/plugin-proposal-decorators @babel/plugin-proposal-class-properties
babel-plugin-module-resolver babel-plugin-transform-typescript-metadata
_______________________________________________________________________________________________________________
> LOCAIS ONDE A PAGINA√áAO EST√Å SENDO IMPLENTADA
- Listagem de clientes
_______________________________________________________________________________________________________________
                          >>>>>>>>> PADR√ïES DE PROJETO E BOAS PR√ÅTICAS <<<<<<<<<<
_______________________________________________________________________________________________________________
                                    >>>>>>>>Domain Driven Design<<<<<<<<
(DDD) - Desenvolvimento Orientado a Dom√≠nio

- N√£o podemos ter nossos servi√ßos e nossas classes de dom√≠nio com conhecimento da ORM que estamos usando, para
em caso de troca, o sistema saiba como lidar com isso
- Essas ferramentas como o Express, o TypeORM fazem parte da infraestrutura do projeto.
- As classes e recursos dos nossos m√≥dulos n√£o podem ter cria√ß√£o de inst√£ncia de nada relacionado a infraestrutura
_______________________________________________________________________________________________________________
                                      >>>>>>>>SOLID - 5 PRINC√çPIOS<<<<<<<<

1: Single-responsability principle: Uma classe deve ter apenas uma √∫nica responsabilidade
2: Open-closed principle: N√£o podemos alterar classes prontas. A medida em que o software vai crescendo, n√£o podemos
alterar uma classe que j√° tem sua responsabilidade para adicionar outra funcionalidade nela. Mas podemos extender ela
em outra classe para usar o que j√° temos, ou criar uma nova classe para atender a essa nova funcionalidade.
3: Liskov substitution principle: O software deve funcionar tanto se for funcionar em uma classe m√£e ou em uma classe filha.
4: Interface Segregation principle: Muitas interfaces especificas √© melhor do que apenas uma geral.
5: Dependency inversions principle: Classes devem depender de abstra√ß√µes e n√£o de implementa√ß√µes
_______________________________________________________________________________________________________________
                                        >>>>>>>>INVERS√ÉO DE DEPENDENCIA<<<<<<<<

- Ao inv√©s dos servi√ßos ficarem respons√°veis por instanciar cada reposit√≥rio, o controller que devera indicar o
reposit√≥rio que o servico vai usar.
_______________________________________________________________________________________________________________
                                        >>>>>>>>INJECAO DE DEPENDENCIA<<<<<<<<
- Para injetar as dependencias como os reposit√≥rios nos servi√ßos, usamos os containeres da biblioteca tysringe,
onde criamos um container passando uma chave e um valor que recebe o reposit√≥rio em quest√£o.
- A partir dessa defini√ß√£o, precisamos adicionar o decorator @injectable na classe do servi√ßo e o decorator
@inject na instancia do repositorio
_______________________________________________________________________________________________________________
                                        >>>>>>>>TESTES AUTOMATIZADOS<<<<<<<<
- JEST: Framework de testes automatizados em JS
- Para realizar testes automatizados usamos um repositorio fake para termos aonde salvar os objetos criados com
os testes.
_______________________________________________________________________________________________________________
* O FakeCustomersRepository traz interessantes formas de manipula√ß√£o de arrays sem o uso de for
